<html lang="en">
	<head>
    <meta charset="utf-8">
    <title>Final project: Social Data Analysis and Visualization</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
		<link rel="stylesheet" href="style.css">
  </head>
  <body>
		<div class="section">
    <div class="map"> </div>
		<div class="hist"> </div>

		<p class ="statistic" id = "2008" > To tusind og otte </p>
		<p class ="statistic" id = "2009" > 2009 </p>
		<p class ="statistic" id = "2010" > 2010 </p>
		<p class ="statistic" id = "2011" > 2011 </p>
		<p class ="statistic" id = "2012" > 2012 </p>
		<p class ="statistic" id = "2013" > 2013 </p>
		<p class ="statistic" id = "2014" > 2014 </p>
    <script type="text/javascript">
    // width and height for map of visualization
    var wMap = 800;
    var hMap = 500;
		var wHist = 800;
		var hHist = 200;

    // define padding
    var paddingMap = 20;
		var paddingHist = 10;

		// Define key function
		var key = function(d){
			return d.key;
		};

		//Define map projection
	  var projection = d3.geoMercator()
                 .translate([wMap/2, hMap/2])
                 .scale((1<<22)/2/Math.PI);
    //Define path generator
    var path = d3.geoPath()
								 .projection(projection)

    var color = ['#64848E', '#DADED6', '#B6A693', '#9A9AA1', '#85818D']

    //Create SVG element
    var svgMap = d3.select("div.map")
       			.append("svg")
  					.attr("width", wMap)
       		  .attr("height", hMap);

    // define zoom function(add scaleExtent if necessary)
/*
	  var zoom = d3.zoom()
           .translateExtent([[ -300, -200 ], [ 300, 200 ]])
           .on("zoom", zooming);

    var zooming = function(d) {
     				//Log out d3.event.transform, so you can see all the goodies inside
     				console.log(d3.event.transform);
     				//New offset array
     				var offset = [d3.event.transform.x, d3.event.transform.y];
     				//Calculate new scale
     				var newScale = d3.event.transform.k * 5000;
     				//Update projection with new offset and scale
     				projection.translate(offset)
     						  .scale(newScale);

     				//Update all paths and circles
     				svgMap.selectAll("path")
     					.attr("d", path);
    };
*/

//Create a container in which all zoom-able elements will live
	  var map = svgMap.append("g")
	        .attr("id", "map");
//	        .call(zoom)  //Bind the zoom behavior
//	        .call(zoom.transform, d3.zoomIdentity  //Then apply the initial transform
//	          .translate(wMap/2, hMap/2)
//	          .scale(1000)
//	          .translate(-center[0], -center[1]));

    //Create a new, invisible background rect to catch zoom events
    map.append("rect")
          	.attr("x", 0)
    				.attr("y", 0)
            .attr("width", wMap)
    				.attr("height", hMap)
            .attr("opacity", 0);

    d3.json("socio_data_kbh.geojson", function(json) {

			var projection = d3.geoMercator().fitSize([wMap, hMap], json);
			var path = d3.geoPath().projection(projection);

			// Make arrays for the different years
			var aar2008 = [];
			var aar2009 = [];
			var aar2010 = [];
			var aar2011 = [];
			var aar2012 = [];
			var aar2013 = [];
			var aar2014 = [];

			d3.csv("Sorted_data.csv",function(data) {
				//dataset = data;
				data.forEach(d => {
					if (+d.aar == 2008) {
						aar2008.push(d);
					}
					else if (+d.aar == 2009) {
						aar2009.push(d);
					}
					else if (+d.aar == 2010) {
						aar2010.push(d);
					}
					else if (+d.aar == 2011) {
						aar2011.push(d);
					}
					else if (+d.aar == 2012) {
						aar2012.push(d);
					}
					else if (+d.aar == 2013) {
						aar2013.push(d);
					}
					else if (+d.aar == 2014) {
						aar2014.push(d);
					}
				})

			// When clicked update with new data sets
	     d3.selectAll("p")
	     	.on("click", function() {
	      	var paragraphID = d3.select(this).attr("id");

					// When 2009 is clicked
	         if (paragraphID == "2009") {

						 // Load in data for the histogram
						 d3.csv("Aggregated_data.csv", function(d) {
							 dataset = data;

						 // Set up the scales
 			      var xScaleHist = d3.scaleBand()
 			        .domain(d3.range(dataset))
 			        .range([0, wHist])
 			        .paddingInner(0.05);
 			      var yScaleHist = d3.scaleLinear()
 			        .domain([0, d3.max(dataset, function(d) {
 			          return d.alder_antal_0_5;
 			        })])
 			        .range([hHist, 0]);

							// Define x axis
							var xAxisHist = d3.axisBottom()
										.scale(xScaleHist);
							// Define y axis
							var yAxisHist = d3.axisLeft()
										.scale(yScaleHist);

						// Set up the svg for the histogram
 			      var svgHist = d3.select("div.hist")
							.append("svg")
							.attr("width", wHist + paddingHist)
							.attr("height", hHist + paddingHist);

							// Make the histogram
							svgHist.append("g")
									.selectAll("rect")
									.data(aar2009)
									.enter()
									.append("rect")
									.attr("x", function(d, i) {
										return xScaleHist(i + 1) + paddingHist;
									})
									.attr("y", function(d) {
										return yScaleHist(d.alder_antal_0_5) + paddingHist * 2;
									})
									.attr("width", xScaleHist.bandwidth())
									.attr("height", function(d, i) {
										return hHist - yScaleHist(d.alder_antal_0_5);
									})
									.attr("fill", function(d) {
										return "rgb(10, " + Math.round(70 + d.alder_antal_0_5 * 4) + "," + Math.round(70 + d.alder_antal_0_5 * 4) + ")";
									});
					});

			map.selectAll('path')
				.data(json.features)
				.enter()
				.append('path')
				.attr('d', path)
				.style("stroke-width", "1")
				.style("stroke", "black")
				.style("fill", function(d){
					return( "rgb(50,0,"+ d.properties.value +")");
				});
			};
		});



			});
		});


/*
			var center = d3.geo.centroid(json)
      var scale  = 1000;
      var offset = [wMap/2, hMap/2];
      var projection = d3.geo.mercator().scale(scale).center(center)
          .translate(offset);

      var path = d3.geo.path().projection(projection);

			var bounds  = path.bounds(json);
      var hscale  = scale*wMap  / (bounds[1][0] - bounds[0][0]);
      var vscale  = scale*hMap / (bounds[1][1] - bounds[0][1]);
      var scale   = (hscale < vscale) ? hscale : vscale;
      var offset  = [wMap - (bounds[0][0] + bounds[1][0])/2,
                        hMap - (bounds[0][1] + bounds[1][1])/2];

			projection = d3.geo.mercator().center(center)
        .scale(scale).translate(offset);
      path = path.projection(projection);


			vis.append("rect").attr('width', width).attr('height', height)
				 .style('stroke', 'black').style('fill', 'none');

			vis.selectAll("path").data(json.features).enter().append("path")
					.attr("d", path)
					.style("fill", "red")
					.style("stroke-width", "1")
					.style("stroke", "black")
*/
			/*map.selectAll("path")
             .data(json.features)
             .enter()
             .append("path")
             .attr("d", path)
             .style("fill","black");

					 });*/
    </script>
  </body>
</html>
