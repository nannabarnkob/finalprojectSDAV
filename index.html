<html lang="en">
	<head>
    <meta charset="utf-8">
    <title>Final project: Social Data Analysis and Visualization</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
		<link rel="stylesheet" href="style.css">
  </head>
  <body>
		<div class="section">
    <div class="viz"> </div>

		<p class ="statistic" id = "2008" > To tusind og otte </p>
		<p class ="statistic" id = "2009" > 2009 </p>
		<p class ="statistic" id = "2010" > 2010 </p>
		<p class ="statistic" id = "2011" > 2011 </p>
		<p class ="statistic" id = "2012" > 2012 </p>
		<p class ="statistic" id = "2013" > 2013 </p>
		<p class ="statistic" id = "2014" > 2014 </p>
    <script type="text/javascript">
    // width and height for map of visualization
    var wMap = 800;
    var hMap = 500;
		var wHist = 800;
		var hHist = 200;

    // define padding
    var paddingMap = 20;
		var paddingHist = 15;

		// Define key function
		var key = function(d){
			return d.key;
		};
/*
		//Define map projection
	  var projection = d3.geoMercator()
                 .translate([wMap/2, hMap/2])
                 .scale((1<<22)/2/Math.PI);
    //Define path generator
    var path = d3.geoPath()
								 .projection(projection)
*/
    var color = ['#64848E', '#DADED6', '#B6A693', '#9A9AA1', '#85818D']

		var key = function(d) {
			return d.key;
		};

    //Create SVG elements for our visualization
    var svgMap = d3.select("div.viz")
       			.append("svg")
  					.attr("width", wMap)
       		  .attr("height", hMap);

		var svgHist = d3.select("div.viz")
						.append("svg")
						.attr("width", wHist + paddingHist)
						.attr("height", hHist + paddingHist);
    // define zoom function(add scaleExtent if necessary)
/*
	  var zoom = d3.zoom()
           .translateExtent([[ -300, -200 ], [ 300, 200 ]])
           .on("zoom", zooming);

    var zooming = function(d) {
     				//Log out d3.event.transform, so you can see all the goodies inside
     				console.log(d3.event.transform);
     				//New offset array
     				var offset = [d3.event.transform.x, d3.event.transform.y];
     				//Calculate new scale
     				var newScale = d3.event.transform.k * 5000;
     				//Update projection with new offset and scale
     				projection.translate(offset)
     						  .scale(newScale);

     				//Update all paths and circles
     				svgMap.selectAll("path")
     					.attr("d", path);
    };
*/

//Create a container in which all zoom-able elements will live
	  var map = svgMap.append("g")
	        .attr("id", "map");
//	        .call(zoom)  //Bind the zoom behavior
//	        .call(zoom.transform, d3.zoomIdentity  //Then apply the initial transform
//	          .translate(wMap/2, hMap/2)
//	          .scale(1000)
//	          .translate(-center[0], -center[1]));

    //Create a new, invisible background rect to catch zoom events
    map.append("rect")
          	.attr("x", 0)
    				.attr("y", 0)
            .attr("width", wMap)
    				.attr("height", hMap)
            .attr("opacity", 0);

    d3.json("socio_data_kbh.geojson", function(json) {

			var projection = d3.geoMercator().fitSize([wMap, hMap], json);
			var path = d3.geoPath().projection(projection);

			// Make arrays for the different years
			var aar2008 = [];
			var aar2009 = [];
			var aar2010 = [];
			var aar2011 = [];
			var aar2012 = [];
			var aar2013 = [];
			var aar2014 = [];

			// array for row with one year observation for creating over all histogram
			var year_observation = [];

			// draw the map using the json file
			map.selectAll('path')
				.data(json.features)
				.enter()
				.append('path')
				.attr('d', path)
				.style("stroke-width", "1")
				.style("stroke", "black")
				.style("fill", function(d){
					return( "rgb(50,0,"+ d.properties.value +")");
				});

			d3.csv("Sorted_data.csv",function(data) {
				//dataset = data;
				data.forEach(d => {
					if (+d.aar == 2008) {
						aar2008.push(d);
					}
					else if (+d.aar == 2009) {
						aar2009.push(d);
					}
					else if (+d.aar == 2010) {
						aar2010.push(d);
					}
					else if (+d.aar == 2011) {
						aar2011.push(d);
					}
					else if (+d.aar == 2012) {
						aar2012.push(d);
					}
					else if (+d.aar == 2013) {
						aar2013.push(d);
					}
					else if (+d.aar == 2014) {
						aar2014.push(d);
					}
				})
			// for showing something when loading the page:
			var paragraphID = "2014"

			d3.csv("Aggregated_data.csv", function(data) {

				console.log('this is the aggregated data:')
				console.log(data)
				data.forEach(function(d) {
						if (+d.aar == Number(paragraphID)) {
							year_observation.push(+d["alder_antal_0_5"])
							year_observation.push(+d["alder_antal_6_17"])
							year_observation.push(+d["alder_antal_18_29"])
							year_observation.push(+d["alder_antal_30_39"])
							year_observation.push(+d["alder_antal_40_49"])
							year_observation.push(+d["alder_antal_50_64"])
							year_observation.push(+d["alder_antal_over_65"])
							/*
							year_observation["age0_5"] = +d["alder_antal_0_5"];
							year_observation["age6_17"] = +d["alder_antal_6_17"];
							year_observation["age18_29"] = +d["alder_antal_18_29"];
							year_observation["age30_39"] = +d["alder_antal_30_39"];
							year_observation["age40_49"] = +d["alder_antal_40_49"];
							year_observation["age50_64"] = +d["alder_antal_50_64"];
							*/
						};
						});
						console.log("This is the year observation array:")
						console.log(year_observation);
						console.log(d3.range(year_observation.length))

			// Set up everything for the first plot
			var xScaleHist = d3.scaleBand()
					 			        .domain(d3.range(year_observation.length))
					 			        .range([paddingHist, wHist])
					 			        .paddingInner(0.05);

			var yScaleHist = d3.scaleLinear()
					 			        .domain([0, d3.max(d3.values(year_observation))])
					 			        .range([hHist, 0]);

												// Define x axis
			var xAxisHist = d3.axisBottom()
												.scale(xScaleHist);
												// Define y axis
		  var yAxisHist = d3.axisLeft()
												.scale(yScaleHist);

									/*		var columns = ["age0_5","age6_17","age18_29","age30_39","age40_49","age50_64"]
												// Make the histogram
											for(var i=0;i<columns.length;i++) {


												var y = columns[i]
												console.log(y);
												var histHeightValue = year_observation[y];
												console.log(histHeightValue);
*/
				svgHist.append("g")
							.selectAll("rect")
							.data(year_observation)
							.enter()
							.append("rect")
							.attr("x", function(d, i) {
								console.log(i)
								console.log(xScaleHist(i))
							return xScaleHist(i) + paddingHist;
							})
							.attr("y", function(d) {
							return yScaleHist(d) + paddingHist * 2;
							})
							.attr("width", xScaleHist.bandwidth())
							.attr("height", function(d, i) {
							return hHist - yScaleHist(d);
							})
							.attr("fill", function(d) {
							return "rgb(10, " + Math.round(70 + d * 4) + "," + Math.round(70 + d * 4) + ")";
							});


					svgHist.append("g")
						.attr("class","axis")
						.attr("transform","translate(" + paddingHist + ",0)")
						.call(yAxisHist);

					svgHist.append("g")
						.attr("class","axis")
						.attr("transform","translate(0," + (hHist - paddingHist) + ")")
						.call(xAxisHist);

				});

			// When clicked update with new data sets
	     d3.selectAll("p")
	     	.on("click", function() {
	      	var paragraphID = d3.select(this).attr("id");

					// Load in data for the histogram depending on the paragraphID
					console.log('this is the aggregated data:')
					console.log(data)
					data.forEach(function(d) {
							if (+d.aar == Number(paragraphID)) {
								year_observation.push(+d["alder_antal_0_5"])
								year_observation.push(+d["alder_antal_6_17"])
								year_observation.push(+d["alder_antal_18_29"])
								year_observation.push(+d["alder_antal_30_39"])
								year_observation.push(+d["alder_antal_40_49"])
								year_observation.push(+d["alder_antal_50_64"])
								year_observation.push(+d["alder_antal_over_65"])
								/*
								year_observation["age0_5"] = +d["alder_antal_0_5"];
								year_observation["age6_17"] = +d["alder_antal_6_17"];
								year_observation["age18_29"] = +d["alder_antal_18_29"];
								year_observation["age30_39"] = +d["alder_antal_30_39"];
								year_observation["age40_49"] = +d["alder_antal_40_49"];
								year_observation["age50_64"] = +d["alder_antal_50_64"];
								*/
							};
							});
							console.log(year_observation);


						 // Set up the scales
 			      var xScaleHist = d3.scaleBand()
 			        .domain(d3.range(year_observation))
 			        .range([0, wHist])
 			        .paddingInner(0.05);

						var yScaleHist = d3.scaleLinear()
 			        .domain([0, d3.max(d3.values(year_observation))])
 			        .range([hHist, 0]);

							// Define x axis
						var xAxisHist = d3.axisBottom()
							.scale(xScaleHist);
							// Define y axis
							var yAxisHist = d3.axisLeft()
							.scale(yScaleHist);

/*
						var columns = ["age0_5","age6_17","age18_29","age30_39","age40_49","age50_64"]
							// Make the histogram
						for(var i=0;i<columns.length;i++) {

							var y = columns[i]
							console.log(y);
							var histHeightValue = year_observation[y];
							console.log(histHeightValue);
*/
							svgHist.append("g")
								.selectAll("rect")
								.data(year_observation)
								.enter()
								.append("rect")
								.attr("x", function(d, i) {
									return xScaleHist(i + 1) + paddingHist;
								})
								.attr("y", function(d) {
									return yScaleHist(d) + paddingHist * 2;
								})
								.attr("width", xScaleHist.bandwidth())
								.attr("height", function(d, i) {
									return hHist - yScaleHist(d);
								})
								.attr("fill", function(d) {
									return "rgb(10, " + Math.round(70 + d * 4) + "," + Math.round(70 + d * 4) + ")";
								});
							});
							});
					});
		//});




/*
			var center = d3.geo.centroid(json)
      var scale  = 1000;
      var offset = [wMap/2, hMap/2];
      var projection = d3.geo.mercator().scale(scale).center(center)
          .translate(offset);

      var path = d3.geo.path().projection(projection);

			var bounds  = path.bounds(json);
      var hscale  = scale*wMap  / (bounds[1][0] - bounds[0][0]);
      var vscale  = scale*hMap / (bounds[1][1] - bounds[0][1]);
      var scale   = (hscale < vscale) ? hscale : vscale;
      var offset  = [wMap - (bounds[0][0] + bounds[1][0])/2,
                        hMap - (bounds[0][1] + bounds[1][1])/2];

			projection = d3.geo.mercator().center(center)
        .scale(scale).translate(offset);
      path = path.projection(projection);


			vis.append("rect").attr('width', width).attr('height', height)
				 .style('stroke', 'black').style('fill', 'none');

			vis.selectAll("path").data(json.features).enter().append("path")
					.attr("d", path)
					.style("fill", "red")
					.style("stroke-width", "1")
					.style("stroke", "black")
*/
			/*map.selectAll("path")
             .data(json.features)
             .enter()
             .append("path")
             .attr("d", path)
             .style("fill","black");

					 });*/
    </script>
  </body>
</html>
