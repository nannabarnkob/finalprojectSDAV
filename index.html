<html lang="en">
	<head>
    <meta charset="utf-8">
    <title>Final project: Social Data Analysis and Visualization</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
		<script src='https://api.mapbox.com/mapbox.js/plugins/turf/v3.0.11/turf.min.js'></script>
		<link rel="stylesheet" href="style.css">
  </head>
	<style>
			.axis text {
		  font: 10px sans-serif;
		}



			.area {
				stroke: none;
			}
			.area:hover {
				fill: yellow;
			}

			rect {
				-moz-transition: all 0.25s;
				-o-transition: all 0.25s;
				-webkit-transition: all 0.25s;
				transition: all 0.25s;
			}

			rect:hover {
				fill: yellow;
			}

			.btn {
		    border: none;
		    background-color: inherit;
		    padding: 14px 28px;
		    font-size: 16px;
		    cursor: pointer;
		    display: inline-block;
			}
			/* Gray */
			.default {
			    color: black;
			}

			.default:hover {
			    background: #e7e7e7;
			}
			.active {
				fill: yellow;
			}
	}
	</style>
  <body>

		<div class="section">
			<p> Here you can move in time and space </p>
    <div class="viz"> </div>

		<button class ="statistic btn default" id = "2008" > 2008 </button>
		<button class ="statistic btn default" id = "2009" > 2009 </button>
		<button class ="statistic btn default" id = "2010" > 2010 </button>
		<button class ="statistic btn default" id = "2011" > 2011 </button>
		<button class ="statistic btn default" id = "2012" > 2012 </button>
		<button class ="statistic btn default" id = "2013" > 2013 </button>
		<button class ="statistic btn default" id = "AllAreas"> View all areas </button>

    <script type="text/javascript">
    // width and height for map of visualization
    var wMap = 1000;
    var hMap = 500;
		var wHist = 500;
		var hHist = 400;
		var wArea = 500;
		var hArea = 400;
		var centered;
    // define padding
    var paddingMap = 20;
		var paddingHist = 30;
		var paddingArea = 20;

		// Define key function
		var key = function(d){
			return d.key;
		};

		function add(a, b) {
    	return a + b;
		}
		// Array for colors
    var color = ['#64848E', '#DADED6', '#B6A693', '#9A9AA1', '#85818D']

    //Create SVG elements for our visualization
    var svgMap = d3.select("div.viz")
       			.append("svg")
  					.attr("width", wMap)
       		  .attr("height", hMap);

		var svgHist = d3.select("div.viz")
						.append("svg")
						.attr("width", wHist + paddingHist)
						.attr("height", hHist + paddingHist);

		var svgArea = d3.select("div.viz")
						.append("svg")
						.attr("width", wArea + paddingArea)
						.attr("height", hArea + paddingArea);

		//Create the map to which we append everything ...
	  var map = svgMap.append("g")
	        .attr("id", "map");

		//Create a new, invisible background rect to catch zoom events
    map.append("rect")
          	.attr("x", 0)
    				.attr("y", 0)
            .attr("width", wMap)
    				.attr("height", hMap)
            .attr("opacity", 0)
						.on("click",clicked);

		// define starting year:
		var paragraphID = "2008"
		var last_chosen_year = "2013"
		var selected_name = "All"

		function clicked(d,json) {
			var projection = d3.geoMercator().fitSize([wMap, hMap], json);
			var x,y,k;
			if(d && centered !== d) {
					var centroid = turf.centroid(d);

				var NewCenter = projection([centroid.geometry.coordinates[0],centroid.geometry.coordinates[1]])
				console.log(NewCenter)
				x = NewCenter[0]
				y = NewCenter[1]
				k = 3;
				centered = d;
			}
			else {
				x = (wMap-200) / 2;
				y = hMap / 2;
				k = 1;
				centered = null;
			}

			map.selectAll("path")
			 .classed("active", centered && function(d) { return d === centered; });

			map.transition()
			 .duration(700)
			 .attr("transform", "translate(" + (wMap-200) / 2 + "," + hMap / 2 + ")scale(" + k + ")translate(" + -x + "," + -y  + ")")
			 .attr("stroke-width", 1.5 / k + "px");
		 }

		var temp2008 = 0
 		var temp2009 = 0;
 		var temp2010 = 0;
 		var temp2011 = 0;
 		var temp2012 = 0;
 		var temp2013 = 0;
 		var temp2014 = 0;

    d3.json("socio_data_kbh.geojson", function(json) {

			console.log(json)
			var year2008 = JSON.parse(JSON.stringify(json))
			var year2009 = JSON.parse(JSON.stringify(json))
			var year2010 = JSON.parse(JSON.stringify(json))
			var year2011 = JSON.parse(JSON.stringify(json))
			var year2012 = JSON.parse(JSON.stringify(json))
			var year2013 = JSON.parse(JSON.stringify(json))
			var year2014 = JSON.parse(JSON.stringify(json))

			var temp2008 = 1
			var temp2009 = 1
			var temp2010 = 0
			var temp2011 = 0
			var temp2012 = 0
			var temp2013 = 0
			var temp2014 = 0

			var L = json.features.length
			for(k = 0; k < L; k++) {
				var d = json.features[k]
				if (+d.properties.aar != 2008) {
					year2008.features.splice(temp2008,1)
					temp2008--
				}
				if (+d.properties.aar != 2009) {
					year2009.features.splice(temp2009,1)
					temp2009--
				}
				if (+d.properties.aar != 2010) {
					year2010.features.splice(temp2010,1)
					temp2010--
				}
				if (+d.properties.aar != 2011) {
					year2011.features.splice(temp2011,1)
					temp2011--
				}
				if (+d.properties.aar != 2012) {
					year2012.features.splice(temp2012,1)
					temp2012--
				}
				if (+d.properties.aar != 2013) {
					year2013.features.splice(temp2013,1)
					temp2013--
				}
				if (+d.properties.aar != 2014) {
					year2014.features.splice(temp2014,1)
					temp2014--
				}
				temp2008++
				temp2009++
				temp2010++
				temp2011++
				temp2012++
				temp2013++
				temp2014++
			}

			console.log(year2009)


			var projection = d3.geoMercator().fitSize([wMap, hMap], year2009);
			var path = d3.geoPath().projection(projection);

			// for adding some zooming behavior

			// Make arrays for the different years


			// array for row with one year observation for creating over all histogram
			var year_observation = [];
			var total_zeros = 0;
			var total_ones = 0;
			var total_twos = 0;
			// draw the map using the json file
			console.log("start")
			map.append("g")
				.selectAll("path")
				.data(year2009.features)
				.enter()
				.append("path")
				.attr("d", path)
				.attr("id",function(d) {
					return d.properties.rode_nr
				})
				.attr("text",function(d) {
					return d.properties.rodenavn
				})
				.attr("stroke-width", "0.5")
				.attr("stroke", "white")
				.attr("fill", function(d, i) {
					//return "rgb(100,200,100)"
					// only use data from chosen year


						// make array of three income values
						var obj = [d.properties.pct_hoj_indkomst, d.properties.pct_middel_indkomst, d.properties.pct_lav_indkomst]


						if (obj.reduce(add, 0) == 0) {

							return "rgb(255, 255, 255)"
						}
						else if(obj.reduce(add, 0) != 0) {
							// find index of max value
							var maxKey = Object.keys(obj).reduce(function(a, b){ return obj[a] > obj[b] ? a : b });
							// only plot color for chosen year:

							//console.log(obj)
							// if most prevalent area is high income:
							if(maxKey == 0) {

								total_zeros += 1
								return "rgb(51, 204, 51)"
							}
							// if most prevalent is middle income:
							if(maxKey == 1) {

								total_ones += 1
								return "rgb(255, 204, 0)"
							}
							// if most prevalent area is low income:
							if(maxKey == 2) {

								total_twos += 1
								return "rgb(255, 0, 0)"
							}
						}
				})
				.on("click",clicked)
				.append("title")
				.text(function(d) {
					return "Area name: " + d.properties.rodenavn
				});


				// log how many low- middle high class areas there should be

				// functions for handling what happens when you hover on the map
				function mouseOverHandler(d, i) {
					d3.select(this).attr("stroke-width", "1.5")

				}
				function mouseOutHandler(d, i) {
					d3.select(this).attr("stroke-width", "0.5")
				}



			d3.csv("Sorted_data.csv",function(data) {
				var sorted_data = data;
				//dataset = data;
/*
				data.forEach(d => {
					if (+d.aar == 2008) {
						aar2008.push(d);
					}
					else if (+d.aar == 2009) {
						aar2009.push(d);
					}
					else if (+d.aar == 2010) {
						aar2010.push(d);
					}
					else if (+d.aar == 2011) {
						aar2011.push(d);
					}
					else if (+d.aar == 2012) {
						aar2012.push(d);
					}
					else if (+d.aar == 2013) {
						aar2013.push(d);
					}
					else if (+d.aar == 2014) {
						aar2014.push(d);
					}
				})
				*/


			// for showing something when loading the page:

			// Load the age data
			d3.csv("Aggregated_data.csv", function(data) {
				age_data = data;

				//console.log('this is the aggregated data:')
				//console.log(data)
				age_data.forEach(function(d) {
						if (+d.aar == Number(paragraphID)) {
							year_observation.push(+d["alder_antal_0_5"])
							year_observation.push(+d["alder_antal_6_17"])
							year_observation.push(+d["alder_antal_18_29"])
							year_observation.push(+d["alder_antal_30_39"])
							year_observation.push(+d["alder_antal_40_49"])
							year_observation.push(+d["alder_antal_50_64"])
							year_observation.push(+d["alder_antal_over_65"])
						};
					});
					console.log("This is the year observation array:")
					console.log(year_observation);
					console.log(d3.range(year_observation.length))
					console.log("max:")
					console.log(d3.max(d3.values(year_observation)))

			// Define xscale for the histogram
			var xScaleHist = d3.scaleBand()
					 			        .domain(d3.range(year_observation.length))
					 			        .range([paddingHist * 2 + 5, wHist])
					 			        .paddingInner(0.05);
			// Define yscale for the histogram
			var yScaleHist = d3.scaleLinear()
					 			        .domain([0, d3.max(d3.values(year_observation))])
					 			        .range([hHist, paddingHist + paddingHist/2]);
			// Create labels for the x axis
			var xLabelHist = d3.scaleBand()
												.domain(["Age 0-5","Age 6-17","Age 18-29","Age 30-39","Age 40-49","Age 50-64", "Above 64"])
												.range([paddingHist * 2 , wHist])
												.paddingInner(0.05);
			// Define x axis
			var xAxisHist = d3.axisBottom()
												.scale(xLabelHist);



			// Define y axis
		  	var yAxisHist = d3.axisLeft()
												.scale(yScaleHist);

			// Create bars
			svgHist.append("g")
							.selectAll("rect")
							.data(year_observation)
							.enter()
							.append("rect")
							.attr("x", function(d, i) {
							return xScaleHist(i);
							})
							.attr("y", function(d) {
							return yScaleHist(d) - paddingHist/2;
							})
							.attr("width", xScaleHist.bandwidth())
							.attr("height", function(d, i) {
							return hHist - yScaleHist(d);
							})
							.attr("fill", function(d) {
							return "rgb(255, 0, 255)";
							})
							.append("title") // for tool tip
							.text(function(d) {
								return "Number of people: " + d3.format(",")(d);
							});

			// Make x axis
			svgHist.append("g")
						.attr("class","x axis")
						.attr("transform","translate(0," + (hHist - paddingHist/2) + ")")
						.call(xAxisHist);

			// Create y axis
			svgHist.append("g")
						.attr("class","y axis")
						.attr("transform","translate(" + paddingHist * 2 + "," + -paddingHist/2 + ")")
						.call(yAxisHist);

				// Create x axis label
				svgHist.append("text")
                      .attr("transform", "translate(" + (wHist/2 + paddingHist) + " , " + (hHist + paddingHist) + " )")
                      .style("text-anchor", "middle")
                      .text("Agegroups")
                      .attr("fill", "black")
                      .attr("font-size","16px");

				// Create y axis label
				svgHist.append("text")
					.attr("transform", "rotate(-90)")
					.attr("x", -hHist/2)
					.attr("y", 0)
					.style("text-anchor", "middle")
					.text("Number of people in the agegroup")
					.attr("fill", "black")
					.attr("font-size","16px");

				// Create header
				svgHist.append("text")
                        .attr("transform", "translate(" + (wHist/2 + paddingHist) + "," + paddingHist/2 + ")")
                        .style("text-anchor", "middle")
                        .text("Age distribution")
                        .attr("font-weight", "bold")
                        .attr("class", "header")
												.attr("id", "headerHist")
                        .attr("font-size","25px");

					//});

				// Create stacked area chart
				// create stack method
			var stack = d3.stack()
				.order(d3.stackOrderDescending);	// flipped stack order

				// load in aggregated education data for "all" option
			d3.csv("Aggregated_data_udd.csv", function(data) {
				console.log("original format of area chart data:")
				console.log(data)
				education_data = data;
				var keys = education_data.columns;
				// remove the first and last column
				keys.shift();
				keys.pop();
				stack.keys(keys);

				var series = stack(education_data);

				var xScaleArea = d3.scaleLinear()
				.domain([2008, d3.max(education_data, function(d) {
					return +d.aar;
				})])
				.range([paddingArea, wArea-paddingArea*2]);

				var yScaleArea = d3.scaleLinear()
					.domain([0,d3.max(education_data, function(d) {
						var sum = 0;
						for (var i = 0; i<keys.length; i++) {
							sum += +d[keys[i]];
						};
						return sum;
					})])
					.range([hArea - paddingArea, paddingArea])
					.nice();

				var xAxisArea = d3.axisBottom()
					.scale(xScaleArea)
					.ticks(7)
					.tickFormat(d3.format(".4"));

				var yAxisArea = d3.axisRight()
					.scale(yScaleArea)
					.ticks(5);

				var area = d3.area()
					.x(function(d) {
						return xScaleArea(d.data.aar);
					})
					.y0(function(d) {
						return yScaleArea(d[0]);
					})
					.y1(function(d) {
						return yScaleArea(d[1]);
					});

				svgArea.selectAll("path")
					.data(series)
					.enter()
					.append("path")
					.attr("class","area")
					.attr("d", area)
					.attr("fill",function(d,i) {
						return d3.schemeCategory20[i];
					})
					.append("title") // for tool tip
					.text(function(d) {
						return d.key;
					})

					svgArea.append("g")
						.attr("class", "x axis")
						.attr("transform", "translate(0," + (hArea - paddingArea) + ")")
						.call(xAxisArea);

					svgArea.append("g")
						.attr("class", "y axis")
						.attr("transform", "translate(" + (wArea - paddingArea * 2) + ", 0)")
						.call(yAxisArea);
						// area chart done


			// new selection on map related to updating histogram
			map.selectAll("path")
				.on("mouseover", mouseOverHandler)
				.on("mouseout", mouseOutHandler)
				.on("click", function(d) {
					console.log(d)
					// highlight selected area:
					d3.select(this).attr("fill", "rgb(200, 0, 100)")

					selected_rodenr = d3.select(this).attr("id");
					selected_name = d3.select(this).attr("text");
					// update title according to selected area:
					svgHist.select(".header").text("Area: " + selected_name + ", year " + paragraphID)

					// collect data for histogram

					var age_distribution_data = [d.properties.alder_antal_0_5, d.properties.alder_antal_6_17, d.properties.alder_antal_18_29, d.properties.alder_antal_30_39, d.properties.alder_antal_40_49,d.properties.alder_antal_50_64, d.properties.alder_antal_over_65]

					console.log(age_distribution_data)
					console.log(selected_rodenr)

					update_histogram(age_distribution_data);
					update_areachart(selected_rodenr)
					// add zoom / panning behavior
					clicked(d,json)
				})

			// When clicked update with new data sets
	     d3.selectAll("button")
	     	.on("click", function(){
	      	var getParagraphID = d3.select(this).attr("id");
					// if selected option is all areas, update using the aggregated data and the previously chosen year
					if (getParagraphID == "AllAreas") {
						// update using aggregated data
						paragraphID = last_chosen_year
						selected_name = "All"
						age_data.forEach(function(d) {
								if (+d.aar == Number(paragraphID)) {
									year_observation.push(+d["alder_antal_0_5"])
									year_observation.push(+d["alder_antal_6_17"])
									year_observation.push(+d["alder_antal_18_29"])
									year_observation.push(+d["alder_antal_30_39"])
									year_observation.push(+d["alder_antal_40_49"])
									year_observation.push(+d["alder_antal_50_64"])
									year_observation.push(+d["alder_antal_over_65"])
								};
							});
							update_histogram(year_observation);

					}
					else {
						paragraphID = getParagraphID
						last_chosen_year = paragraphID
					}

					svgHist.select(".header").text("Area: " + selected_name + ", year " + paragraphID)
					year_observation = [];

					// currently take aggregated age data to show, this should only happen if viewing all areas

						update_map(paragraphID)
					});

 				// Function for updating the area chart
			function update_map(paragraphID) {

				console.log("updating map")
				map.selectAll("path")
				.attr("fill", function(d, i) {
					//return "rgb(100,200,100)"
					// only use data from chosen year
					if (+d.properties.aar == Number(paragraphID)) {
						// make array of three income values
						var obj = [d.properties.pct_hoj_indkomst, d.properties.pct_middel_indkomst, d.properties.pct_lav_indkomst]
						console.log(obj)



						if (obj.reduce(add, 0) == 0) {
							console.log("Array was zeros, no income data")
							return "rgb(255, 204, 0)"
						}
						else if(obj.reduce(add, 0) != 0) {
							// find index of max value
							var maxKey = Object.keys(obj).reduce(function(a, b){ return obj[a] > obj[b] ? a : b });
							// only plot color for chosen year:
							console.log(+d.properties.aar)
							console.log(maxKey)
							//console.log(obj)
							// if most prevalent area is high income:
							if(maxKey == 0) {
								console.log("Making a high income color")
								total_zeros += 1
								return "rgb(51, 204, 51)"
							}
							// if most prevalent is middle income:
							if(maxKey == 1) {
								console.log("Making a middle income color")
								total_ones += 1
								return "rgb(255, 204, 0)"
							}
							// if most prevalent area is low income:
							if(maxKey == 2) {
								console.log("Making a low income color")
								total_twos += 1
								return "rgb(255, 0, 0)"
							}
						}
					}
				});
			}

	function update_areachart(selected_rodenr) {

		// 1. update data set based on rode_nr - could be done on nested data but now just matching criteria
		var education_data_rodenr = []
		console.log("executing update areachart")

		sorted_data.forEach(d => {
			if (+d.rode_nr == selected_rodenr) {
				education_data_rodenr.push(d);
			}
		})
		console.log("education data for rodenr: " + selected_rodenr)


		var education_data_subset = education_data_rodenr.map(function(d,i) {
		  return {
		    aar: d.aar,
				antal_gymnasial_udd: d.antal_gymnasial_udd,
				antal_erh_faglig_udd: d.antal_erh_faglig_udd,
				antal_kort_viderg_udd: d.antal_kort_viderg_udd,
				antal_mellemlang_viderg_udd: d.antal_mellemlang_viderg_udd,
		    antal_lang_viderg_udd: d.antal_lang_viderg_udd,
				antal_ingen_udd: d.antal_ingen_udd,
				antal_under_udd: d.antal_under_udd
		  };
		});

		console.log(education_data_subset)
		var keys = Object.getOwnPropertyNames(education_data_subset[0]);
		// remove the first and last column
		keys.shift();
		stack.keys(keys);

		var series = stack(education_data_subset);

	// 2. redefine y axis domain
		var yScaleArea = d3.scaleLinear()
				.domain([0,d3.max(education_data_subset, function(d) {
					var sum = 0;
					for (var i = 0; i<keys.length; i++) {
						sum += +d[keys[i]];
					};
					return sum;
				})]);

		var area = d3.area()
					.x(function(d) {
						return xScaleArea(d.data.aar);
					})
					.y0(function(d) {
						return yScaleArea(d[0]);
					})
					.y1(function(d) {
						return yScaleArea(d[1]);
					});

					// 3. update paths and y axis
		svgArea.selectAll("path")
			.data(series)
			.transition()
				.duration(2500)
				.attr("d", area)
				.delay(function(d, i) {
									return i / series.length;
			})
			.ease(d3.easeLinear)
			.attr("fill",function(d,i) {
				return d3.schemeCategory20[i];
			});
//			.append("title") // for tool tip
//			.text(function(d) {
//				return d.key;
//			});


			svgArea.select(".y.axis")
				.transition()
				.duration(1000)
				.call(yAxisHist);
	}



	// Function for updating the histogram using a simple array for input
	function update_histogram(age_data_array) {

		// update the y scale
		yScaleHist.domain([0, d3.max(d3.values(age_data_array))]);

		// Update bars
		svgHist.selectAll("rect")
				.data(age_data_array)
				.transition()
				.delay(function(d, i) {
					return i / age_data_array.length;
				})
				.duration(1000)
				.ease(d3.easeLinear)
				.attr("x", function(d, i) {
				return xScaleHist(i);
				})
				.attr("y", function(d) {
				return yScaleHist(d) - paddingHist/2;
				})
				.attr("width", xScaleHist.bandwidth())
				.attr("height", function(d, i) {
				return hHist - yScaleHist(d);
				})
				.attr("fill", function(d) {
				return "rgb(255, 0, 255)";
				})
				.text(function(d) {
					return "Number of people: " + d3.format(",")(d);
				});

		// Update y axis
		svgHist.select(".y.axis")
					.transition()
					.duration(1000)
					.call(yAxisHist);
	}



	});


							});
					});
			});





/*
			var center = d3.geo.centroid(json)
      var scale  = 1000;
      var offset = [wMap/2, hMap/2];
      var projection = d3.geo.mercator().scale(scale).center(center)
          .translate(offset);

      var path = d3.geo.path().projection(projection);

			var bounds  = path.bounds(json);
      var hscale  = scale*wMap  / (bounds[1][0] - bounds[0][0]);
      var vscale  = scale*hMap / (bounds[1][1] - bounds[0][1]);
      var scale   = (hscale < vscale) ? hscale : vscale;
      var offset  = [wMap - (bounds[0][0] + bounds[1][0])/2,
                        hMap - (bounds[0][1] + bounds[1][1])/2];

			projection = d3.geo.mercator().center(center)
        .scale(scale).translate(offset);
      path = path.projection(projection);


			vis.append("rect").attr('width', width).attr('height', height)
				 .style('stroke', 'black').style('fill', 'none');

			vis.selectAll("path").data(json.features).enter().append("path")
					.attr("d", path)
					.style("fill", "red")
					.style("stroke-width", "1")
					.style("stroke", "black")
*/
			/*map.selectAll("path")
             .data(json.features)
             .enter()
             .append("path")
             .attr("d", path)
             .style("fill","black");

					 });

function clicked(d) {
		d3.json("socio_data_kbh.geojson", function(json){
			var projection = d3.geoMercator().fitSize([wMap, hMap], json);
				var x,y,k;
				if(d && centered !== d){
						var centroid = turf.centroid(d);

					NewCenter = projection([centroid.geometry.coordinates[0],centroid.geometry.coordinates[1]])
					console.log(NewCenter)
					x = NewCenter[0]
					y = NewCenter[1]
					k = 3;
					centered = d;
				} else{
					x = (wMap-200) / 2;
					y = hMap / 2;
					k = 1;
					centered = null;
				}
	map.selectAll("path")
	 .classed("active", centered && function(d) { return d === centered; });

	map.transition()
	 .duration(700)
	 .attr("transform", "translate(" + (wMap-200) / 2 + "," + hMap / 2 + ")scale(" + k + ")translate(" + -x + "," + -y  + ")")
	 .style("stroke-width", 1.5 / k + "px");
	})
}
*/
    </script>
  </body>
</html>
