<html lang="en">
	<head>
    <meta charset="utf-8">
    <title>Final project: Social Data Analysis and Visualization</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
		<link rel="stylesheet" href="style.css">
  </head>
	<style>
			.axis text {
		  font: 10px sans-serif;
		}

			.area {
				stroke: none;
			}
			.area:hover {
				fill: yellow;
			}
	}
	</style>
  <body>
		<div class="section">
    <div class="viz"> </div>

		<p class ="statistic" id = "2008" > 2008 </p>
		<p class ="statistic" id = "2009" > 2009 </p>
		<p class ="statistic" id = "2010" > 2010 </p>
		<p class ="statistic" id = "2011" > 2011 </p>
		<p class ="statistic" id = "2012" > 2012 </p>
		<p class ="statistic" id = "2013" > 2013 </p>
		<p class ="statistic" id = "2014" > 2014 </p>
    <script type="text/javascript">
    // width and height for map of visualization
    var wMap = 1000;
    var hMap = 500;
		var wHist = 500;
		var hHist = 400;
		var wArea = 500;
		var hArea = 400;
    // define padding
    var paddingMap = 20;
		var paddingHist = 30;
		var paddingArea = 20;

		// Define key function
		var key = function(d){
			return d.key;
		};
/*
		//Define map projection
	  var projection = d3.geoMercator()
                 .translate([wMap/2, hMap/2])
                 .scale((1<<22)/2/Math.PI);
    //Define path generator
    var path = d3.geoPath()
								 .projection(projection)
*/
    var color = ['#64848E', '#DADED6', '#B6A693', '#9A9AA1', '#85818D']

		var key = function(d) {
			return d.key;
		};

    //Create SVG elements for our visualization
    var svgMap = d3.select("div.viz")
       			.append("svg")
  					.attr("width", wMap)
       		  .attr("height", hMap);

		var svgHist = d3.select("div.viz")
						.append("svg")
						.attr("width", wHist + paddingHist)
						.attr("height", hHist + paddingHist);

		var svgArea = d3.select("div.viz")
						.append("svg")
						.attr("width", wArea + paddingArea)
						.attr("height", hArea + paddingArea);
    // define zoom function(add scaleExtent if necessary)
/*
	  var zoom = d3.zoom()
           .translateExtent([[ -300, -200 ], [ 300, 200 ]])
           .on("zoom", zooming);

    var zooming = function(d) {
     				//Log out d3.event.transform, so you can see all the goodies inside
     				console.log(d3.event.transform);
     				//New offset array
     				var offset = [d3.event.transform.x, d3.event.transform.y];
     				//Calculate new scale
     				var newScale = d3.event.transform.k * 5000;
     				//Update projection with new offset and scale
     				projection.translate(offset)
     						  .scale(newScale);

     				//Update all paths and circles
     				svgMap.selectAll("path")
     					.attr("d", path);
    };
*/

//Create a container in which all zoom-able elements will live
	  var map = svgMap.append("g")
	        .attr("id", "map");
//	        .call(zoom)  //Bind the zoom behavior
//	        .call(zoom.transform, d3.zoomIdentity  //Then apply the initial transform
//	          .translate(wMap/2, hMap/2)
//	          .scale(1000)
//	          .translate(-center[0], -center[1]));

    //Create a new, invisible background rect to catch zoom events
    map.append("rect")
          	.attr("x", 0)
    				.attr("y", 0)
            .attr("width", wMap)
    				.attr("height", hMap)
            .attr("opacity", 0);

		// define starting year:
		var paragraphID = "2008"

    d3.json("socio_data_kbh.geojson", function(json) {
			console.log(json)
			var projection = d3.geoMercator().fitSize([wMap, hMap], json);
			var path = d3.geoPath().projection(projection);

			// Make arrays for the different years
			var aar2008 = [];
			var aar2009 = [];
			var aar2010 = [];
			var aar2011 = [];
			var aar2012 = [];
			var aar2013 = [];
			var aar2014 = [];

			// array for row with one year observation for creating over all histogram
			var year_observation = [];

			// draw the map using the json file
			map.selectAll('path')
				.data(json.features)
				.enter()
				.append('path')
				.attr('d', path)
				.style("stroke-width", "1")
				.style("stroke", "black")
				.style("fill", function(d){
					// make array of three income values
					var obj = [d.properties.pct_hoj_indkomst, d.properties.pct_middel_indkomst, d.properties.pct_lav_indkomst]
					// find index of max value
					var maxKey = Object.keys(obj).reduce(function(a, b){ return obj[a] > obj[b] ? a : b });
					// only plot color for chosen year:

					if (+d.properties.aar == Number(paragraphID)) {
						console.log(+d.properties.aar)
						console.log(maxKey)
						console.log(obj)
						// if most prevalent area is high income:
						if(maxKey == 0) {
							return "rgb(0,250,250)";
						}
						// if most prevalent is middle income:
						if(maxKey == 1) {
							return "rgb(100, 0, 100)";
						}
						// if most prevalent area is low income:
						if(maxKey == 2) {
							return "rgb(100, 100, 0)";
						}
					}
				});

			d3.csv("Sorted_data.csv",function(data) {
				//dataset = data;
				data.forEach(d => {
					if (+d.aar == 2008) {
						aar2008.push(d);
					}
					else if (+d.aar == 2009) {
						aar2009.push(d);
					}
					else if (+d.aar == 2010) {
						aar2010.push(d);
					}
					else if (+d.aar == 2011) {
						aar2011.push(d);
					}
					else if (+d.aar == 2012) {
						aar2012.push(d);
					}
					else if (+d.aar == 2013) {
						aar2013.push(d);
					}
					else if (+d.aar == 2014) {
						aar2014.push(d);
					}
				})


			// for showing something when loading the page:


			d3.csv("Aggregated_data.csv", function(data) {

				console.log('this is the aggregated data:')
				console.log(data)
				data.forEach(function(d) {
						if (+d.aar == Number(paragraphID)) {
							year_observation.push(+d["alder_antal_0_5"])
							year_observation.push(+d["alder_antal_6_17"])
							year_observation.push(+d["alder_antal_18_29"])
							year_observation.push(+d["alder_antal_30_39"])
							year_observation.push(+d["alder_antal_40_49"])
							year_observation.push(+d["alder_antal_50_64"])
							year_observation.push(+d["alder_antal_over_65"])
						};
					});
					console.log("This is the year observation array:")
					console.log(year_observation);
					console.log(d3.range(year_observation.length))
					console.log("max:")
					console.log(d3.max(d3.values(year_observation)))

			// Set up everything for the first plot
			var xScaleHist = d3.scaleBand()
					 			        .domain(d3.range(year_observation.length))
					 			        .range([paddingHist + 5, wHist])
					 			        .paddingInner(0.05);

			var yScaleHist = d3.scaleLinear()
					 			        .domain([0, d3.max(d3.values(year_observation))])
					 			        .range([hHist, 0]);

			var xLabelHist = d3.scaleBand()
												.domain(["Age 0-5","Age 6-17","Age 18-29","Age 30-39","Age 40-49","Age 50-64", "Above 64"])
												.range([paddingHist,wHist])
												.paddingInner(0.05);
												// Define x axis
			var xAxisHist = d3.axisBottom()
												.scale(xLabelHist);



												// Define y axis
		  var yAxisHist = d3.axisLeft()
												.scale(yScaleHist);

			// create bars
			svgHist.append("g")
							.selectAll("rect")
							.data(year_observation)
							.enter()
							.append("rect")
							.attr("x", function(d, i) {
							return xScaleHist(i);
							})
							.attr("y", function(d) {
							return yScaleHist(d);
							})
							.attr("width", xScaleHist.bandwidth())
							.attr("height", function(d, i) {
							return hHist - yScaleHist(d);
							})
							.attr("fill", function(d) {
							return "rgb(10, " + Math.round(70 + d * 4) + "," + Math.round(70 + d * 4) + ")";
							});

					// Make y axis
			svgHist.append("g")
						.attr("class","y axis")
						.attr("transform","translate(" + paddingHist + ",0)")
						.call(yAxisHist);

			// Make x axis
			svgHist.append("g")
						.attr("class","x axis")
						.attr("transform","translate(0," + hHist + ")")
						.call(xAxisHist);
				});

			// When clicked update with new data sets
	     d3.selectAll("p")
	     	.on("click", function() {
	      	var paragraphID = d3.select(this).attr("id");

					// Load in data for the histogram depending on the paragraphID
					console.log('this is the aggregated data:')
					console.log(data)
					data.forEach(function(d) {
							if (+d.aar == Number(paragraphID)) {
								year_observation.push(+d["alder_antal_0_5"])
								year_observation.push(+d["alder_antal_6_17"])
								year_observation.push(+d["alder_antal_18_29"])
								year_observation.push(+d["alder_antal_30_39"])
								year_observation.push(+d["alder_antal_40_49"])
								year_observation.push(+d["alder_antal_50_64"])
								year_observation.push(+d["alder_antal_over_65"])
							};
							});
							console.log(year_observation);
						 // Set up the scales
 			      var xScaleHist = d3.scaleBand()
 			        //.domain(d3.range(year_observation+1))
							.domain(d3.range(year_observation.length))
 			        .range([0, wHist])
 			        .paddingInner(0.05);

						var yScaleHist = d3.scaleLinear()
 			        .domain([0, d3.max(d3.values(year_observation))])
 			        .range([hHist, 0]);

						var xLabelHist = d3.scaleBand()
							.domain(["age0_5","age6_17","age18_29","age30_39","age40_49","age50_64"])
							.range([0,wHist])
							.paddingInner(0.05);
							// Define x axis
						var xAxisHist = d3.axisBottom()
							.scale(xLabelHist)
							.ticks(7);
							// Define y axis
							var yAxisHist = d3.axisLeft()
							.scale(yScaleHist);


/*
						var columns = ["age0_5","age6_17","age18_29","age30_39","age40_49","age50_64"]
							// Make the histogram
						for(var i=0;i<columns.length;i++) {

							var y = columns[i]
							console.log(y);
							var histHeightValue = year_observation[y];
							console.log(histHeightValue);
*/
							svgHist.append("g")
								.selectAll("rect")
								.data(year_observation)
								.enter()
								.append("rect")
								.attr("x", function(d, i) {
									return xScaleHist(i + 1) + paddingHist;
								})
								.attr("y", function(d) {
									return yScaleHist(d) + paddingHist * 2;
								})
								.attr("width", xScaleHist.bandwidth())
								.attr("height", function(d, i) {
									return hHist - yScaleHist(d);
								})
								.attr("fill", function(d) {
									return "rgb(10, " + Math.round(70 + d * 4) + "," + Math.round(70 + d * 4) + ")";
								});
							});
							});
					});
		//});

			// create stack method
			var stack = d3.stack()
				.order(d3.stackOrderDescending);	// flipped stack order

			d3.csv("Aggregated_data_udd.csv", function(data) {
				console.log(data)
				education_data = data;
				var keys = education_data.columns;
				// remove the first three columns
				keys.shift();
				keys.pop();
				stack.keys(keys);

				var series = stack(education_data);

				var xScaleArea = d3.scaleLinear()
				.domain([2008, d3.max(education_data, function(d) {
					return +d.aar;
				})])
				.range([paddingArea, wArea-paddingArea*2]);

				var yScaleArea = d3.scaleLinear()
					.domain([0,d3.max(education_data, function(d) {
						var sum = 0;
						for (var i = 0; i<keys.length; i++) {
							sum += +d[keys[i]];
						};
						return sum;
					})])
					.range([hArea - paddingArea, paddingArea])
					.nice();

				var xAxisArea = d3.axisBottom()
					.scale(xScaleArea)
					.ticks(7);

				var yAxisArea = d3.axisRight()
					.scale(yScaleArea)
					.ticks(5);

				var area = d3.area()
					.x(function(d) {
						return xScaleArea(d.data.aar);
					})
					.y0(function(d) {
						return yScaleArea(d[0]);
					})
					.y1(function(d) {
						return yScaleArea(d[1]);
					});

				svgArea.selectAll("path")
					.data(series)
					.enter()
					.append("path")
					.attr("class","area")
					.attr("d", area)
					.attr("fill",function(d,i) {
						return d3.schemeCategory20[i];
					})
					.append("title") // for tool tip
					.text(function(d) {
						return d.key;
					})

					svgArea.append("g")
						.attr("class", "axis")
						.attr("transform", "translate(0," + (hArea - paddingArea) + ")")
						.call(xAxisArea);

					svgArea.append("g")
						.attr("class", "axis")
						.attr("transform", "translate(" + (wArea - paddingArea * 2) + ", 0)")
						.call(yAxisArea);

				//	});


			});





/*
			var center = d3.geo.centroid(json)
      var scale  = 1000;
      var offset = [wMap/2, hMap/2];
      var projection = d3.geo.mercator().scale(scale).center(center)
          .translate(offset);

      var path = d3.geo.path().projection(projection);

			var bounds  = path.bounds(json);
      var hscale  = scale*wMap  / (bounds[1][0] - bounds[0][0]);
      var vscale  = scale*hMap / (bounds[1][1] - bounds[0][1]);
      var scale   = (hscale < vscale) ? hscale : vscale;
      var offset  = [wMap - (bounds[0][0] + bounds[1][0])/2,
                        hMap - (bounds[0][1] + bounds[1][1])/2];

			projection = d3.geo.mercator().center(center)
        .scale(scale).translate(offset);
      path = path.projection(projection);


			vis.append("rect").attr('width', width).attr('height', height)
				 .style('stroke', 'black').style('fill', 'none');

			vis.selectAll("path").data(json.features).enter().append("path")
					.attr("d", path)
					.style("fill", "red")
					.style("stroke-width", "1")
					.style("stroke", "black")
*/
			/*map.selectAll("path")
             .data(json.features)
             .enter()
             .append("path")
             .attr("d", path)
             .style("fill","black");

					 });*/
    </script>
  </body>
</html>
